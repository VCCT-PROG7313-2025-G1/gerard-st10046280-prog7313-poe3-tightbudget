package com.example.tightbudget.utils

import android.content.Context
import android.graphics.Canvas
import android.graphics.Color
import android.graphics.DashPathEffect
import android.graphics.Paint
import android.graphics.Path
import android.graphics.PointF
import android.graphics.RectF
import android.graphics.Typeface
import android.view.View
import androidx.core.content.ContextCompat
import com.example.tightbudget.R
import java.util.Locale
import kotlin.math.cos
import kotlin.math.max
import kotlin.math.min
import kotlin.math.sin

/**
 * Utility class for chart creation and manipulation
 * This class was generated by ChatGPT and is used to create various chart views. It has been
 * modified by me to fit the app's needs.
 */
object ChartUtils {

    /**
     * Create a simple donut chart view with category spending data
     */
    fun createDonutChartView(context: Context, categoryAmounts: Map<String, Float>): DonutChartView {
        return DonutChartView(context, categoryAmounts)
    }

    /**
     * Creates an enhanced donut chart with category labels and percentages
     */
    fun createEnhancedDonutChartView(
        context: Context,
        categoryData: List<CategorySpendingData>,
        totalAmount: Float
    ): EnhancedDonutChartView {
        return EnhancedDonutChartView(context, categoryData, totalAmount)
    }

    /**
     * Creates a bar chart view for category comparisons with budget limits
     */
    fun createCategoryBarChartView(
        context: Context,
        categoryData: List<CategorySpendingData>
    ): CategoryBarChartView {
        return CategoryBarChartView(context, categoryData)
    }

    /**
     * Data class to hold category spending information for charts
     */
    data class CategorySpendingData(
        val name: String,
        val amount: Float,
        val budgetLimit: Float,
        val color: Int,
        val emoji: String = ""
    ) {
        fun getPercentage(total: Float): Float = if (total > 0) (amount / total) * 100 else 0f

        fun getBudgetStatus(): BudgetStatus {
            return when {
                amount > budgetLimit -> BudgetStatus.OVER_BUDGET
                amount > budgetLimit * 0.9 -> BudgetStatus.NEAR_LIMIT
                else -> BudgetStatus.UNDER_BUDGET
            }
        }
    }

    enum class BudgetStatus {
        OVER_BUDGET, NEAR_LIMIT, UNDER_BUDGET
    }

    /**
     * Custom view for displaying a donut chart
     */
    class DonutChartView(context: Context, private val data: Map<String, Float>) : View(context) {
        private val paint = Paint(Paint.ANTI_ALIAS_FLAG)
        private val rect = RectF()
        private val centerText = Paint(Paint.ANTI_ALIAS_FLAG).apply {
            color = Color.BLACK
            textSize = 54f
            textAlign = Paint.Align.CENTER
            typeface = Typeface.create(Typeface.DEFAULT, Typeface.BOLD)
        }

        private var total: Float = data.values.sum()
        private var centerTextString = "R${String.format(Locale.getDefault(), "%.2f", total)}"

        init {
            if (total == 0f) total = 1f
        }

        override fun onDraw(canvas: Canvas) {
            super.onDraw(canvas)

            val width = width.toFloat()
            val height = height.toFloat()
            val radius = (min(width, height) / 2 * 0.8).toFloat()
            val strokeWidth = radius * 0.2f

            rect.set(
                width / 2 - radius,
                height / 2 - radius,
                width / 2 + radius,
                height / 2 + radius
            )

            var startAngle = 0f
            data.forEach { (categoryName, amount) ->
                val sweepAngle = 360f * (amount / total)

                paint.style = Paint.Style.STROKE
                paint.strokeWidth = strokeWidth
                paint.color = DrawableUtils.getCategoryColor(context, categoryName)

                canvas.drawArc(rect, startAngle, sweepAngle, false, paint)
                startAngle += sweepAngle
            }

            canvas.drawText(
                centerTextString,
                width / 2,
                height / 2 + centerText.textSize / 3f,
                centerText
            )
        }
    }

    /**
     * Enhanced donut chart with labels and percentages
     */
    class EnhancedDonutChartView(
        context: Context,
        private val categories: List<CategorySpendingData>,
        private val totalAmount: Float
    ) : View(context) {
        // Paint objects for drawing
        private val arcPaint = Paint(Paint.ANTI_ALIAS_FLAG)
        private val textPaint = Paint(Paint.ANTI_ALIAS_FLAG).apply {
            color = Color.WHITE
            textSize = 32f
            textAlign = Paint.Align.CENTER
        }
        private val labelPaint = Paint(Paint.ANTI_ALIAS_FLAG).apply {
            color = Color.WHITE
            textSize = 24f
            textAlign = Paint.Align.CENTER
        }
        private val centerTextPaint = Paint(Paint.ANTI_ALIAS_FLAG).apply {
            color = Color.BLACK
            textSize = 48f
            textAlign = Paint.Align.CENTER
            typeface = Typeface.create(Typeface.DEFAULT, Typeface.BOLD)
        }

        // Drawing areas
        private val arcRect = RectF()
        private val centerText = "R${String.format(Locale.getDefault(), "%,.2f", totalAmount)}"

        override fun onDraw(canvas: Canvas) {
            super.onDraw(canvas)

            val centerX = width / 2f
            val centerY = height / 2f
            val radius = min(width, height) / 2f * 0.7f

            // Set up the arc area
            arcRect.set(
                centerX - radius,
                centerY - radius,
                centerX + radius,
                centerY + radius
            )

            // Draw the donut chart
            var startAngle = 0f
            categories.forEach { category ->
                val sweepAngle = (category.amount / totalAmount) * 360f

                arcPaint.style = Paint.Style.FILL
                arcPaint.color = category.color

                canvas.drawArc(arcRect, startAngle, sweepAngle, true, arcPaint)

                // Calculate label position
                val labelAngle = Math.toRadians((startAngle + sweepAngle / 2).toDouble())
                val labelRadius = radius * 0.8f
                val labelX = centerX + (labelRadius * cos(labelAngle)).toFloat()
                val labelY = centerY + (labelRadius * sin(labelAngle)).toFloat()

                // Only draw labels for segments large enough to be visible
                if (sweepAngle > 15) {
                    val percentage = String.format("%.1f%%", category.getPercentage(totalAmount))
                    canvas.drawText(percentage, labelX, labelY, labelPaint)
                }

                startAngle += sweepAngle
            }

            // Draw center white circle to create donut effect
            arcPaint.color = Color.WHITE
            canvas.drawCircle(centerX, centerY, radius * 0.5f, arcPaint)

            // Draw center text (total amount)
            canvas.drawText(centerText, centerX, centerY + centerTextPaint.textSize / 4, centerTextPaint)
        }
    }

    /**
     * Bar chart for category spending vs budget
     */
    class CategoryBarChartView(
        context: Context,
        private val categories: List<CategorySpendingData>
    ) : View(context) {
        private val barPaint = Paint(Paint.ANTI_ALIAS_FLAG)
        private val textPaint = Paint(Paint.ANTI_ALIAS_FLAG).apply {
            color = Color.BLACK
            textSize = 30f
        }
        private val limitPaint = Paint(Paint.ANTI_ALIAS_FLAG).apply {
            color = Color.RED
            style = Paint.Style.STROKE
            strokeWidth = 3f
            pathEffect = DashPathEffect(floatArrayOf(10f, 5f), 0f)
        }

        override fun onDraw(canvas: Canvas) {
            super.onDraw(canvas)

            if (categories.isEmpty()) return

            val padding = 60f
            val axisLabelWidth = 120f
            val barHeight = 50f
            val maxBarWidth = width - axisLabelWidth - padding * 2

            // Find maximum value for scaling
            val maxValue = categories.maxOf {
                max(it.amount, it.budgetLimit)
            }.coerceAtLeast(1f)

            // Draw each category bar
            categories.forEachIndexed { index, category ->
                val y = padding + index * (barHeight + 40f)

                // Draw category name with emoji
                textPaint.textAlign = Paint.Align.LEFT
                val displayName = if (category.emoji.isNotEmpty()) "${category.emoji} ${category.name}" else category.name
                canvas.drawText(
                    displayName,
                    padding,
                    y + barHeight / 2 + textPaint.textSize / 3,
                    textPaint
                )

                // Draw bar
                val barWidth = (category.amount / maxValue) * maxBarWidth
                barPaint.color = category.color
                canvas.drawRect(
                    axisLabelWidth,
                    y,
                    axisLabelWidth + barWidth,
                    y + barHeight,
                    barPaint
                )

                // Draw budget limit line
                val limitX = axisLabelWidth + (category.budgetLimit / maxValue) * maxBarWidth
                canvas.drawLine(
                    limitX,
                    y - 10f,
                    limitX,
                    y + barHeight + 10f,
                    limitPaint
                )

                // Draw amount label
                textPaint.textAlign = Paint.Align.LEFT
                canvas.drawText(
                    "R${String.format("%,.0f", category.amount)}",
                    axisLabelWidth + barWidth + 10f,
                    y + barHeight / 2 + textPaint.textSize / 3,
                    textPaint
                )
            }
        }
    }

    /**
     * Enhanced line chart for daily spending
     */
    class EnhancedLineChartView(
        context: Context,
        private val dataPoints: Map<String, Float>,
        private val dateFormat: Boolean = true
    ) : View(context) {
        private val linePaint = Paint().apply {
            color = ContextCompat.getColor(context, R.color.teal_light)
            strokeWidth = 6f
            style = Paint.Style.STROKE
            isAntiAlias = true
        }

        private val pointPaint = Paint().apply {
            color = ContextCompat.getColor(context, R.color.teal_light)
            style = Paint.Style.FILL
            isAntiAlias = true
        }

        private val textPaint = Paint().apply {
            color = Color.DKGRAY
            textSize = 24f
            isAntiAlias = true
            textAlign = Paint.Align.CENTER
        }

        private val gridPaint = Paint().apply {
            color = Color.LTGRAY
            strokeWidth = 1f
            style = Paint.Style.STROKE
            pathEffect = DashPathEffect(floatArrayOf(5f, 5f), 0f)
        }

        override fun onDraw(canvas: Canvas) {
            super.onDraw(canvas)

            if (dataPoints.isEmpty()) return

            val padding = 60f
            val chartWidth = width - 2 * padding
            val chartHeight = height - 2 * padding - 40f // Extra space for labels

            // Get data in order
            val sortedData = dataPoints.entries.sortedBy { it.key }
            val maxY = sortedData.maxOfOrNull { it.value }?.coerceAtLeast(1f) ?: 1f

            // Draw grid lines
            val gridLines = 4
            for (i in 0..gridLines) {
                val y = padding + chartHeight * (1 - i.toFloat() / gridLines)
                canvas.drawLine(padding, y, width - padding, y, gridPaint)

                // Draw y-axis labels
                val value = (maxY * i / gridLines)
                textPaint.textAlign = Paint.Align.RIGHT
                canvas.drawText(
                    "R${String.format("%,.0f", value)}",
                    padding - 10,
                    y + textPaint.textSize / 3,
                    textPaint
                )
            }

            // Draw data points and connecting lines
            val points = sortedData.mapIndexed { index, (_, value) ->
                PointF(
                    padding + index * chartWidth / (sortedData.size - 1),
                    padding + chartHeight * (1 - (value / maxY))
                )
            }

            // Draw smooth curve
            val path = Path()
            if (points.isNotEmpty()) {
                path.moveTo(points[0].x, points[0].y)

                for (i in 1 until points.size) {
                    val prevPoint = points[i-1]
                    val currentPoint = points[i]

                    // Control points for cubic curve
                    val controlX1 = prevPoint.x + (currentPoint.x - prevPoint.x) / 3
                    val controlY1 = prevPoint.y
                    val controlX2 = prevPoint.x + 2 * (currentPoint.x - prevPoint.x) / 3
                    val controlY2 = currentPoint.y

                    path.cubicTo(
                        controlX1, controlY1,
                        controlX2, controlY2,
                        currentPoint.x, currentPoint.y
                    )
                }

                canvas.drawPath(path, linePaint)
            }

            // Draw points and labels
            sortedData.forEachIndexed { index, (label, value) ->
                val x = padding + index * chartWidth / (sortedData.size - 1)
                val y = padding + chartHeight * (1 - (value / maxY))

                // Draw point
                canvas.drawCircle(x, y, 8f, pointPaint)

                // Draw x-axis label
                textPaint.textAlign = Paint.Align.CENTER
                val displayLabel = if (dateFormat) {
                    // Format date labels for better display
                    label.split(" ").getOrNull(1) ?: label
                } else {
                    label
                }

                canvas.drawText(
                    displayLabel,
                    x,
                    height - 16f,
                    textPaint
                )
            }
        }
    }

    /**
     * Creates and returns a forecast chart view
     */
    fun createForecastChartView(
        context: Context,
        currentSpending: Float,
        budgetAmount: Float,
        forecastAmount: Float,
        daysRatio: Float // 0.0 to 1.0 representing how far through the period we are
    ): ForecastChartView {
        return ForecastChartView(context, currentSpending, budgetAmount, forecastAmount, daysRatio)
    }

    /**
     * Custom view for forecast visualization
     */
    class ForecastChartView(
        context: Context,
        private val currentSpending: Float,
        private val budgetAmount: Float,
        private val forecastAmount: Float,
        private val daysRatio: Float
    ) : View(context) {
        private val barPaint = Paint(Paint.ANTI_ALIAS_FLAG)
        private val textPaint = Paint(Paint.ANTI_ALIAS_FLAG).apply {
            color = Color.BLACK
            textSize = 30f
        }
        private val currentMarkerPaint = Paint(Paint.ANTI_ALIAS_FLAG).apply {
            color = ContextCompat.getColor(context, R.color.primary_purple_light)
            style = Paint.Style.FILL
        }
        private val budgetMarkerPaint = Paint(Paint.ANTI_ALIAS_FLAG).apply {
            color = Color.BLACK
            style = Paint.Style.FILL
        }

        override fun onDraw(canvas: Canvas) {
            super.onDraw(canvas)

            val padding = 40f
            val height = 60f
            val maxValue = max(forecastAmount, budgetAmount) * 1.1f
            val barWidth = width - padding * 2

            // Draw background bar
            barPaint.color = Color.LTGRAY
            canvas.drawRect(
                padding,
                height,
                width - padding,
                height * 2,
                barPaint
            )

            // Draw current spending bar
            barPaint.color = getTrendColor(currentSpending, budgetAmount, daysRatio)
            val currentWidth = (currentSpending / maxValue) * barWidth
            canvas.drawRect(
                padding,
                height,
                padding + currentWidth,
                height * 2,
                barPaint
            )

            // Draw current position marker
            val markerX = padding + (daysRatio * barWidth)
            val markerPath = Path()
            markerPath.moveTo(markerX, height - 20)
            markerPath.lineTo(markerX - 10, height - 30)
            markerPath.lineTo(markerX + 10, height - 30)
            markerPath.close()
            canvas.drawPath(markerPath, currentMarkerPaint)
            canvas.drawText("Today", markerX, height - 40, textPaint)

            // Draw budget marker
            val budgetX = padding + (budgetAmount / maxValue) * barWidth
            canvas.drawRect(budgetX - 2, height - 10, budgetX + 2, height * 2 + 10, budgetMarkerPaint)
            textPaint.textAlign = Paint.Align.CENTER
            canvas.drawText("Budget", budgetX, height * 2 + 40, textPaint)
        }

        private fun getTrendColor(current: Float, budget: Float, daysRatio: Float): Int {
            val projectedEnd = current / daysRatio
            return when {
                projectedEnd > budget * 1.1f -> ContextCompat.getColor(context, R.color.red_light)
                projectedEnd > budget -> ContextCompat.getColor(context, R.color.orange)
                else -> ContextCompat.getColor(context, R.color.teal_light)
            }
        }
    }

    /**
     * Creates a list of default category spending data for preview/placeholder
     */
    fun getDefaultCategoryData(context: Context): List<CategorySpendingData> {
        return listOf(
            CategorySpendingData(
                name = "Housing",
                amount = 6511.19f,
                budgetLimit = 6000f,
                color = ContextCompat.getColor(context, R.color.teal_light),
                emoji = "üè†"
            ),
            CategorySpendingData(
                name = "Food",
                amount = 4259.08f,
                budgetLimit = 5000f,
                color = ContextCompat.getColor(context, R.color.primary_purple_light),
                emoji = "üçî"
            ),
            CategorySpendingData(
                name = "Transport",
                amount = 2328.71f,
                budgetLimit = 2500f,
                color = ContextCompat.getColor(context, R.color.blue_light),
                emoji = "üöó"
            ),
            CategorySpendingData(
                name = "Entertainment",
                amount = 2221.47f,
                budgetLimit = 1500f,
                color = ContextCompat.getColor(context, R.color.gray_medium),
                emoji = "üé¨"
            )
        )
    }

    /**
     * Creates default daily spending data for placeholder
     */
    fun getDefaultDailyData(): Map<String, Float> {
        return mapOf(
            "9 Mar" to 354.25f,
            "10 Mar" to 682.50f,
            "11 Mar" to 285.75f,
            "12 Mar" to 421.30f,
            "13 Mar" to 398.60f,
            "14 Mar" to 753.40f,
            "15 Mar" to 544.80f
        )
    }
}
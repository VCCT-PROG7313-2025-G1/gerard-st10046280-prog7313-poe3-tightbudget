package com.example.tightbudget.utils

import android.util.Log
import com.example.tightbudget.data.AppDatabase
import com.example.tightbudget.models.CategoryBudget
import com.example.tightbudget.ui.CategoryBudgetItem
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import java.util.Calendar

/**
 * Manages category budget allocations, including loading, saving,
 * and distribution algorithms.
 * This class is responsible for:
 * - Loading category allocations for a specific budget goal
 * - Creating default allocations for a new budget goal
 * - Saving category allocations
 * - Adjusting allocations when the total budget changes
 * - Distributing additional amounts across categories
 * - Calculating spending statistics by category
 * This class was generated by ChatGPT and modified to fit the app's needs.
 */
class CategoryAllocationManager(private val database: AppDatabase) {
    private val TAG = "CategoryAllocationManager"

    /**
     * Loads category allocations for a specific budget goal
     */
    suspend fun loadCategoryAllocations(budgetGoalId: Int): List<CategoryBudgetItem> =
        withContext(Dispatchers.IO) {
            try {
                val categoryBudgetDao = database.categoryBudgetDao()
                val categoryDao = database.categoryDao()

                // Get all categories for their emoji and color
                val allCategories = categoryDao.getAllCategories()

                // Get budget allocations for this goal
                val categoryBudgets = categoryBudgetDao.getCategoryBudgetsForGoal(budgetGoalId)

                // Convert to UI items
                return@withContext categoryBudgets.map { categoryBudget ->
                    // Find matching category for emoji and color
                    val category = allCategories.find { it.name == categoryBudget.categoryName }

                    CategoryBudgetItem(
                        categoryName = categoryBudget.categoryName,
                        emoji = category?.emoji
                            ?: EmojiUtils.getCategoryEmoji(categoryBudget.categoryName),
                        color = category?.color ?: "#CCCCCC",
                        allocation = categoryBudget.allocation,
                        id = categoryBudget.id
                    )
                }
            } catch (e: Exception) {
                Log.e(TAG, "Error loading category allocations: ${e.message}", e)
                return@withContext emptyList<CategoryBudgetItem>()
            }
        }

    /**
     * Creates default allocations for a new budget goal
     */
    suspend fun createDefaultAllocations(totalBudget: Double): List<CategoryBudgetItem> =
        withContext(Dispatchers.IO) {
            try {
                val categoryDao = database.categoryDao()
                val allCategories = categoryDao.getAllCategories()

                // Smart allocation algorithm:
                // 1. Essential categories get higher percentage
                // 2. Other categories get even distribution of remaining budget

                val essentialCategories = listOf("Housing", "Groceries", "Utilities", "Transport")
                val essentialPercentage = 0.65 // 65% for essential categories

                val results = mutableListOf<CategoryBudgetItem>()
                var remainingBudget = totalBudget

                // First, allocate to essentials
                val essentialCats = allCategories.filter {
                    essentialCategories.contains(it.name)
                }

                if (essentialCats.isNotEmpty()) {
                    val essentialBudget = totalBudget * essentialPercentage
                    remainingBudget -= essentialBudget

                    // Distribute essential budget among essential categories
                    val perEssentialCat = essentialBudget / essentialCats.size

                    for (cat in essentialCats) {
                        results.add(
                            CategoryBudgetItem(
                                categoryName = cat.name,
                                emoji = cat.emoji,
                                color = cat.color,
                                allocation = perEssentialCat
                            )
                        )
                    }
                }

                // Distribute remaining budget to other categories
                val otherCats = allCategories.filter {
                    !essentialCategories.contains(it.name)
                }

                if (otherCats.isNotEmpty()) {
                    val perOtherCat = remainingBudget / otherCats.size

                    for (cat in otherCats) {
                        results.add(
                            CategoryBudgetItem(
                                categoryName = cat.name,
                                emoji = cat.emoji,
                                color = cat.color,
                                allocation = perOtherCat
                            )
                        )
                    }
                }

                return@withContext results
            } catch (e: Exception) {
                Log.e(TAG, "Error creating default allocations: ${e.message}", e)
                return@withContext emptyList<CategoryBudgetItem>()
            }
        }

    /**
     * Saves category allocations for a budget goal
     */
    suspend fun saveCategoryAllocations(
        budgetGoalId: Int,
        categoryItems: List<CategoryBudgetItem>
    ) = withContext(Dispatchers.IO) {
        try {
            val categoryBudgetDao = database.categoryBudgetDao()

            // First delete existing allocations
            categoryBudgetDao.deleteCategoryBudgetsForGoal(budgetGoalId)

            // Then insert new ones
            for (item in categoryItems) {
                val categoryBudget = CategoryBudget(
                    id = 0, // Always insert new
                    budgetGoalId = budgetGoalId,
                    categoryName = item.categoryName,
                    allocation = item.allocation
                )
                categoryBudgetDao.insertCategoryBudget(categoryBudget)
            }

            return@withContext true
        } catch (e: Exception) {
            Log.e(TAG, "Error saving category allocations: ${e.message}", e)
            return@withContext false
        }
    }

    /**
     * Adjusts category allocations proportionally when total budget changes
     */
    fun adjustAllocationsByRatio(
        categoryItems: List<CategoryBudgetItem>,
        oldTotal: Double,
        newTotal: Double
    ): List<CategoryBudgetItem> {
        if (oldTotal <= 0 || categoryItems.isEmpty()) return categoryItems

        val ratio = newTotal / oldTotal
        return categoryItems.map { item ->
            item.copy(allocation = item.allocation * ratio)
        }
    }

    /**
     * Distributes an additional amount across categories
     */
    fun distributeAdditionalAmount(
        categoryItems: List<CategoryBudgetItem>,
        additionalAmount: Double
    ): List<CategoryBudgetItem> {
        if (categoryItems.isEmpty()) return categoryItems

        val perCategoryAmount = additionalAmount / categoryItems.size
        return categoryItems.map { item ->
            item.copy(allocation = item.allocation + perCategoryAmount)
        }
    }

    /**
     * Calculates spending statistics by category
     */
    suspend fun getCategorySpendingStats(
        userId: Int,
        month: Int,
        year: Int
    ): Map<String, Double> = withContext(Dispatchers.IO) {
        try {
            val transactionDao = database.transactionDao()

            // Create date range for the specified month
            val calendar = Calendar.getInstance()
            calendar.set(year, month - 1, 1, 0, 0, 0) // First day of month
            val startDate = calendar.time

            calendar.set(
                year,
                month - 1,
                calendar.getActualMaximum(Calendar.DAY_OF_MONTH),
                23,
                59,
                59
            ) // Last day of month
            val endDate = calendar.time

            // Get transactions for the period
            val transactions = transactionDao.getTransactionsForPeriod(userId, startDate, endDate)

            // Group transactions by category and sum amounts
            return@withContext transactions.groupBy { it.category }
                .mapValues { entry ->
                    entry.value.sumOf { it.amount }
                }
        } catch (e: Exception) {
            Log.e(TAG, "Error calculating category spending: ${e.message}", e)
            return@withContext emptyMap<String, Double>()
        }
    }
}